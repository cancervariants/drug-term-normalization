"""Tools for analyzing normalization output."""
import math
from typing import Tuple, Dict, Optional

import plotly.graph_objects as go
import networkx as nx

from therapy.query import QueryHandler
from therapy.schemas import MatchType, UnmergedNormalizationService


def get_graph_positions(
    response: UnmergedNormalizationService,
) -> Tuple[nx.classes.graph.Graph, Dict]:
    """
    Generate node positions for graph using Kamada-Kawai algorithm.
    :param response: successful response from normalize_unmerged method.
    :return: networkx Graph object and positions Dict
    """
    edges = []
    nodes = set()
    for source in response.source_matches.values():
        for record in source.records:
            nodes.add(record.concept_id)
            for ref in record.xrefs:  # type: ignore
                edges.append((record.concept_id, ref))
    edges = [(e1, e2) for (e1, e2) in edges if e1 in nodes and e2 in nodes]

    G = nx.Graph()
    for (e1, e2) in edges:
        G.add_edge(e1, e2)
    return G, nx.kamada_kawai_layout(G)


def get_graph_scatter(pos: Dict) -> go.Scatter:
    """
    Construct scatter plot for graph nodes.
    :param pos: positions generated by Kamada-Kawai algorithm.
    :return: scatter object
    """
    node_x = [v[0] for v in pos.values()]
    node_y = [v[1] for v in pos.values()]
    node_trace = go.Scatter(
        x=node_x,
        y=node_y,
        mode="markers",
        hoverinfo="text",
        marker=dict(
            showscale=True,
            colorscale="Bluered",
            reversescale=True,
            color=[],
            size=10,
            colorbar=dict(
                thickness=15,
                title="Betweenness Centrality",
                xanchor="left",
                titleside="right",
            ),
            line_width=2,
        ),
    )
    return node_trace


def scale_points(
    x_1: float, y_1: float, x_2: float, y_2: float, radius: float
) -> Tuple[float, float]:
    """Scale coordinates to ensure that xref arrows don't overlap
    :param x_1: x coordinate of first end
    :param y_1: y coordinate of first end
    :param x_2: x coordinate of second end
    :param y_2: y coordinate of second end
    :param radius: approximation of point radius to scale away
    :return: scaled set of coordinates
    """
    d = math.sqrt((y_2 - y_1) ** 2 + (x_2 - x_1) ** 2)
    x_prime = radius * (x_2 - x_1) / d
    y_prime = radius * (y_2 - y_1) / d
    return (x_prime + x_1, y_prime + y_1)


def draw_graph(q: QueryHandler, drug_term: str) -> Optional[go.Figure]:
    """Draw visualization of record relationships under normalized term.
    :param q: handler to process query
    :param drug_term: term to search for
    :return: Plotly figure object if successful. If in a console, will launch a
    Plotly service in the default web browser.
    """
    response = q.normalize_unmerged(drug_term)
    if response.match_type == MatchType.NO_MATCH:
        return None
    G, pos = get_graph_positions(response)
    node_trace = get_graph_scatter(pos)

    node_trace.marker.color = list(nx.betweenness_centrality(G).values())
    node_trace.text = list(G.nodes())

    fig = go.Figure(
        data=[node_trace],
        layout=go.Layout(
            title=f"{drug_term} normalized group",
            titlefont_size=16,
            showlegend=False,
            hovermode="closest",
            margin=dict(b=20, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        ),
    )

    RADIUS = 0.01
    for start, end in G.edges():
        x_1, y_1 = pos[start]
        x_2, y_2 = pos[end]
        x_1_p, y_1_p = scale_points(x_1, y_1, x_2, y_2, RADIUS)
        x_2_p, y_2_p = scale_points(x_2, y_2, x_1, y_1, RADIUS)
        fig.add_annotation(
            x=x_1_p,
            y=y_1_p,
            ax=x_2_p,
            ay=y_2_p,
            xref="x",
            yref="y",
            axref="x",
            ayref="y",
            text="",
            showarrow=True,
            arrowhead=1,
            arrowsize=2,
            arrowwidth=1,
            arrowcolor="black",
        )

    fig.update_layout(width=700, height=700)
    fig.show()
    return fig
